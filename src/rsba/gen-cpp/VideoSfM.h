/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef VideoSfM_H
#define VideoSfM_H

#define GLOG_NO_ABBREVIATED_SEVERITIES
#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "sfm_types.h"

namespace vision { namespace sfm { namespace gen {

#ifdef _WIN32
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class VideoSfMIf {
 public:
  virtual ~VideoSfMIf() {}
  virtual void authenticate(std::string& _return) = 0;
  virtual int32_t newSession(const std::string& authToken, const std::vector<double> & camera) = 0;
  virtual int32_t cloneSession(const std::string& authToken, const int32_t oldSessionKey) = 0;
  virtual int32_t newRsSession(const std::string& authToken, const std::vector<double> & camera, const RollingShutter::type rs, const std::vector<int32_t> & scanlines) = 0;
  virtual int32_t newFrame(const std::string& authToken, const int32_t sessionKey, const Frame& frame) = 0;
  virtual void getFrame(Frame& _return, const std::string& authToken, const int32_t sessionKey, const int32_t frameKey) = 0;
  virtual int32_t newTrack(const std::string& authToken, const int32_t sessionKey, const Track& track) = 0;
  virtual void getTracks(std::vector<Track> & _return, const std::string& authToken, const int32_t sessionKey) = 0;
  virtual void initialize(const std::string& authToken, const int32_t sessionKey) = 0;
  virtual bool fullBA(const std::string& authToken, const int32_t sessionKey, const int32_t maxIter, const bool reproject) = 0;
  virtual bool windowedBA(const std::string& authToken, const int32_t sessionKey, const int32_t startFrame, const int32_t endFrame, const int32_t maxIter, const bool reproject) = 0;
  virtual void finalize(const std::string& authToken, const int32_t sessionKey) = 0;
};

class VideoSfMIfFactory {
 public:
  typedef VideoSfMIf Handler;

  virtual ~VideoSfMIfFactory() {}

  virtual VideoSfMIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(VideoSfMIf* /* handler */) = 0;
};

class VideoSfMIfSingletonFactory : virtual public VideoSfMIfFactory {
 public:
  VideoSfMIfSingletonFactory(const boost::shared_ptr<VideoSfMIf>& iface) : iface_(iface) {}
  virtual ~VideoSfMIfSingletonFactory() {}

  virtual VideoSfMIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(VideoSfMIf* /* handler */) {}

 protected:
  boost::shared_ptr<VideoSfMIf> iface_;
};

class VideoSfMNull : virtual public VideoSfMIf {
 public:
  virtual ~VideoSfMNull() {}
  void authenticate(std::string& /* _return */) {
    return;
  }
  int32_t newSession(const std::string& /* authToken */, const std::vector<double> & /* camera */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t cloneSession(const std::string& /* authToken */, const int32_t /* oldSessionKey */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t newRsSession(const std::string& /* authToken */, const std::vector<double> & /* camera */, const RollingShutter::type /* rs */, const std::vector<int32_t> & /* scanlines */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t newFrame(const std::string& /* authToken */, const int32_t /* sessionKey */, const Frame& /* frame */) {
    int32_t _return = 0;
    return _return;
  }
  void getFrame(Frame& /* _return */, const std::string& /* authToken */, const int32_t /* sessionKey */, const int32_t /* frameKey */) {
    return;
  }
  int32_t newTrack(const std::string& /* authToken */, const int32_t /* sessionKey */, const Track& /* track */) {
    int32_t _return = 0;
    return _return;
  }
  void getTracks(std::vector<Track> & /* _return */, const std::string& /* authToken */, const int32_t /* sessionKey */) {
    return;
  }
  void initialize(const std::string& /* authToken */, const int32_t /* sessionKey */) {
    return;
  }
  bool fullBA(const std::string& /* authToken */, const int32_t /* sessionKey */, const int32_t /* maxIter */, const bool /* reproject */) {
    bool _return = false;
    return _return;
  }
  bool windowedBA(const std::string& /* authToken */, const int32_t /* sessionKey */, const int32_t /* startFrame */, const int32_t /* endFrame */, const int32_t /* maxIter */, const bool /* reproject */) {
    bool _return = false;
    return _return;
  }
  void finalize(const std::string& /* authToken */, const int32_t /* sessionKey */) {
    return;
  }
};


class VideoSfM_authenticate_args {
 public:

  VideoSfM_authenticate_args(const VideoSfM_authenticate_args&);
  VideoSfM_authenticate_args& operator=(const VideoSfM_authenticate_args&);
  VideoSfM_authenticate_args() {
  }

  virtual ~VideoSfM_authenticate_args() throw();

  bool operator == (const VideoSfM_authenticate_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const VideoSfM_authenticate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_authenticate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_authenticate_pargs {
 public:


  virtual ~VideoSfM_authenticate_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_authenticate_result__isset {
  _VideoSfM_authenticate_result__isset() : success(false) {}
  bool success :1;
} _VideoSfM_authenticate_result__isset;

class VideoSfM_authenticate_result {
 public:

  VideoSfM_authenticate_result(const VideoSfM_authenticate_result&);
  VideoSfM_authenticate_result& operator=(const VideoSfM_authenticate_result&);
  VideoSfM_authenticate_result() : success() {
  }

  virtual ~VideoSfM_authenticate_result() throw();
  std::string success;

  _VideoSfM_authenticate_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const VideoSfM_authenticate_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_authenticate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_authenticate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_authenticate_presult__isset {
  _VideoSfM_authenticate_presult__isset() : success(false) {}
  bool success :1;
} _VideoSfM_authenticate_presult__isset;

class VideoSfM_authenticate_presult {
 public:


  virtual ~VideoSfM_authenticate_presult() throw();
  std::string* success;

  _VideoSfM_authenticate_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_newSession_args__isset {
  _VideoSfM_newSession_args__isset() : authToken(false), camera(false) {}
  bool authToken :1;
  bool camera :1;
} _VideoSfM_newSession_args__isset;

class VideoSfM_newSession_args {
 public:

  VideoSfM_newSession_args(const VideoSfM_newSession_args&);
  VideoSfM_newSession_args& operator=(const VideoSfM_newSession_args&);
  VideoSfM_newSession_args() : authToken() {
  }

  virtual ~VideoSfM_newSession_args() throw();
  std::string authToken;
  std::vector<double>  camera;

  _VideoSfM_newSession_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_camera(const std::vector<double> & val);

  bool operator == (const VideoSfM_newSession_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(camera == rhs.camera))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newSession_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newSession_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_newSession_pargs {
 public:


  virtual ~VideoSfM_newSession_pargs() throw();
  const std::string* authToken;
  const std::vector<double> * camera;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newSession_result__isset {
  _VideoSfM_newSession_result__isset() : success(false) {}
  bool success :1;
} _VideoSfM_newSession_result__isset;

class VideoSfM_newSession_result {
 public:

  VideoSfM_newSession_result(const VideoSfM_newSession_result&);
  VideoSfM_newSession_result& operator=(const VideoSfM_newSession_result&);
  VideoSfM_newSession_result() : success(0) {
  }

  virtual ~VideoSfM_newSession_result() throw();
  int32_t success;

  _VideoSfM_newSession_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const VideoSfM_newSession_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newSession_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newSession_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newSession_presult__isset {
  _VideoSfM_newSession_presult__isset() : success(false) {}
  bool success :1;
} _VideoSfM_newSession_presult__isset;

class VideoSfM_newSession_presult {
 public:


  virtual ~VideoSfM_newSession_presult() throw();
  int32_t* success;

  _VideoSfM_newSession_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_cloneSession_args__isset {
  _VideoSfM_cloneSession_args__isset() : authToken(false), oldSessionKey(false) {}
  bool authToken :1;
  bool oldSessionKey :1;
} _VideoSfM_cloneSession_args__isset;

class VideoSfM_cloneSession_args {
 public:

  VideoSfM_cloneSession_args(const VideoSfM_cloneSession_args&);
  VideoSfM_cloneSession_args& operator=(const VideoSfM_cloneSession_args&);
  VideoSfM_cloneSession_args() : authToken(), oldSessionKey(0) {
  }

  virtual ~VideoSfM_cloneSession_args() throw();
  std::string authToken;
  int32_t oldSessionKey;

  _VideoSfM_cloneSession_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_oldSessionKey(const int32_t val);

  bool operator == (const VideoSfM_cloneSession_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(oldSessionKey == rhs.oldSessionKey))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_cloneSession_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_cloneSession_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_cloneSession_pargs {
 public:


  virtual ~VideoSfM_cloneSession_pargs() throw();
  const std::string* authToken;
  const int32_t* oldSessionKey;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_cloneSession_result__isset {
  _VideoSfM_cloneSession_result__isset() : success(false) {}
  bool success :1;
} _VideoSfM_cloneSession_result__isset;

class VideoSfM_cloneSession_result {
 public:

  VideoSfM_cloneSession_result(const VideoSfM_cloneSession_result&);
  VideoSfM_cloneSession_result& operator=(const VideoSfM_cloneSession_result&);
  VideoSfM_cloneSession_result() : success(0) {
  }

  virtual ~VideoSfM_cloneSession_result() throw();
  int32_t success;

  _VideoSfM_cloneSession_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const VideoSfM_cloneSession_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_cloneSession_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_cloneSession_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_cloneSession_presult__isset {
  _VideoSfM_cloneSession_presult__isset() : success(false) {}
  bool success :1;
} _VideoSfM_cloneSession_presult__isset;

class VideoSfM_cloneSession_presult {
 public:


  virtual ~VideoSfM_cloneSession_presult() throw();
  int32_t* success;

  _VideoSfM_cloneSession_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_newRsSession_args__isset {
  _VideoSfM_newRsSession_args__isset() : authToken(false), camera(false), rs(false), scanlines(false) {}
  bool authToken :1;
  bool camera :1;
  bool rs :1;
  bool scanlines :1;
} _VideoSfM_newRsSession_args__isset;

class VideoSfM_newRsSession_args {
 public:

  VideoSfM_newRsSession_args(const VideoSfM_newRsSession_args&);
  VideoSfM_newRsSession_args& operator=(const VideoSfM_newRsSession_args&);
  VideoSfM_newRsSession_args() : authToken(), rs((RollingShutter::type)0) {
  }

  virtual ~VideoSfM_newRsSession_args() throw();
  std::string authToken;
  std::vector<double>  camera;
  RollingShutter::type rs;
  std::vector<int32_t>  scanlines;

  _VideoSfM_newRsSession_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_camera(const std::vector<double> & val);

  void __set_rs(const RollingShutter::type val);

  void __set_scanlines(const std::vector<int32_t> & val);

  bool operator == (const VideoSfM_newRsSession_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(camera == rhs.camera))
      return false;
    if (!(rs == rhs.rs))
      return false;
    if (!(scanlines == rhs.scanlines))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newRsSession_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newRsSession_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_newRsSession_pargs {
 public:


  virtual ~VideoSfM_newRsSession_pargs() throw();
  const std::string* authToken;
  const std::vector<double> * camera;
  const RollingShutter::type* rs;
  const std::vector<int32_t> * scanlines;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newRsSession_result__isset {
  _VideoSfM_newRsSession_result__isset() : success(false) {}
  bool success :1;
} _VideoSfM_newRsSession_result__isset;

class VideoSfM_newRsSession_result {
 public:

  VideoSfM_newRsSession_result(const VideoSfM_newRsSession_result&);
  VideoSfM_newRsSession_result& operator=(const VideoSfM_newRsSession_result&);
  VideoSfM_newRsSession_result() : success(0) {
  }

  virtual ~VideoSfM_newRsSession_result() throw();
  int32_t success;

  _VideoSfM_newRsSession_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const VideoSfM_newRsSession_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newRsSession_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newRsSession_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newRsSession_presult__isset {
  _VideoSfM_newRsSession_presult__isset() : success(false) {}
  bool success :1;
} _VideoSfM_newRsSession_presult__isset;

class VideoSfM_newRsSession_presult {
 public:


  virtual ~VideoSfM_newRsSession_presult() throw();
  int32_t* success;

  _VideoSfM_newRsSession_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_newFrame_args__isset {
  _VideoSfM_newFrame_args__isset() : authToken(false), sessionKey(false), frame(false) {}
  bool authToken :1;
  bool sessionKey :1;
  bool frame :1;
} _VideoSfM_newFrame_args__isset;

class VideoSfM_newFrame_args {
 public:

  VideoSfM_newFrame_args(const VideoSfM_newFrame_args&);
  VideoSfM_newFrame_args& operator=(const VideoSfM_newFrame_args&);
  VideoSfM_newFrame_args() : authToken(), sessionKey(0) {
  }

  virtual ~VideoSfM_newFrame_args() throw();
  std::string authToken;
  int32_t sessionKey;
  Frame frame;

  _VideoSfM_newFrame_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  void __set_frame(const Frame& val);

  bool operator == (const VideoSfM_newFrame_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    if (!(frame == rhs.frame))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newFrame_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newFrame_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_newFrame_pargs {
 public:


  virtual ~VideoSfM_newFrame_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;
  const Frame* frame;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newFrame_result__isset {
  _VideoSfM_newFrame_result__isset() : success(false) {}
  bool success :1;
} _VideoSfM_newFrame_result__isset;

class VideoSfM_newFrame_result {
 public:

  VideoSfM_newFrame_result(const VideoSfM_newFrame_result&);
  VideoSfM_newFrame_result& operator=(const VideoSfM_newFrame_result&);
  VideoSfM_newFrame_result() : success(0) {
  }

  virtual ~VideoSfM_newFrame_result() throw();
  int32_t success;

  _VideoSfM_newFrame_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const VideoSfM_newFrame_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newFrame_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newFrame_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newFrame_presult__isset {
  _VideoSfM_newFrame_presult__isset() : success(false) {}
  bool success :1;
} _VideoSfM_newFrame_presult__isset;

class VideoSfM_newFrame_presult {
 public:


  virtual ~VideoSfM_newFrame_presult() throw();
  int32_t* success;

  _VideoSfM_newFrame_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_getFrame_args__isset {
  _VideoSfM_getFrame_args__isset() : authToken(false), sessionKey(false), frameKey(false) {}
  bool authToken :1;
  bool sessionKey :1;
  bool frameKey :1;
} _VideoSfM_getFrame_args__isset;

class VideoSfM_getFrame_args {
 public:

  VideoSfM_getFrame_args(const VideoSfM_getFrame_args&);
  VideoSfM_getFrame_args& operator=(const VideoSfM_getFrame_args&);
  VideoSfM_getFrame_args() : authToken(), sessionKey(0), frameKey(0) {
  }

  virtual ~VideoSfM_getFrame_args() throw();
  std::string authToken;
  int32_t sessionKey;
  int32_t frameKey;

  _VideoSfM_getFrame_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  void __set_frameKey(const int32_t val);

  bool operator == (const VideoSfM_getFrame_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    if (!(frameKey == rhs.frameKey))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_getFrame_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_getFrame_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_getFrame_pargs {
 public:


  virtual ~VideoSfM_getFrame_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;
  const int32_t* frameKey;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_getFrame_result__isset {
  _VideoSfM_getFrame_result__isset() : success(false) {}
  bool success :1;
} _VideoSfM_getFrame_result__isset;

class VideoSfM_getFrame_result {
 public:

  VideoSfM_getFrame_result(const VideoSfM_getFrame_result&);
  VideoSfM_getFrame_result& operator=(const VideoSfM_getFrame_result&);
  VideoSfM_getFrame_result() {
  }

  virtual ~VideoSfM_getFrame_result() throw();
  Frame success;

  _VideoSfM_getFrame_result__isset __isset;

  void __set_success(const Frame& val);

  bool operator == (const VideoSfM_getFrame_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_getFrame_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_getFrame_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_getFrame_presult__isset {
  _VideoSfM_getFrame_presult__isset() : success(false) {}
  bool success :1;
} _VideoSfM_getFrame_presult__isset;

class VideoSfM_getFrame_presult {
 public:


  virtual ~VideoSfM_getFrame_presult() throw();
  Frame* success;

  _VideoSfM_getFrame_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_newTrack_args__isset {
  _VideoSfM_newTrack_args__isset() : authToken(false), sessionKey(false), track(false) {}
  bool authToken :1;
  bool sessionKey :1;
  bool track :1;
} _VideoSfM_newTrack_args__isset;

class VideoSfM_newTrack_args {
 public:

  VideoSfM_newTrack_args(const VideoSfM_newTrack_args&);
  VideoSfM_newTrack_args& operator=(const VideoSfM_newTrack_args&);
  VideoSfM_newTrack_args() : authToken(), sessionKey(0) {
  }

  virtual ~VideoSfM_newTrack_args() throw();
  std::string authToken;
  int32_t sessionKey;
  Track track;

  _VideoSfM_newTrack_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  void __set_track(const Track& val);

  bool operator == (const VideoSfM_newTrack_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    if (!(track == rhs.track))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newTrack_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newTrack_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_newTrack_pargs {
 public:


  virtual ~VideoSfM_newTrack_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;
  const Track* track;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newTrack_result__isset {
  _VideoSfM_newTrack_result__isset() : success(false) {}
  bool success :1;
} _VideoSfM_newTrack_result__isset;

class VideoSfM_newTrack_result {
 public:

  VideoSfM_newTrack_result(const VideoSfM_newTrack_result&);
  VideoSfM_newTrack_result& operator=(const VideoSfM_newTrack_result&);
  VideoSfM_newTrack_result() : success(0) {
  }

  virtual ~VideoSfM_newTrack_result() throw();
  int32_t success;

  _VideoSfM_newTrack_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const VideoSfM_newTrack_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newTrack_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newTrack_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newTrack_presult__isset {
  _VideoSfM_newTrack_presult__isset() : success(false) {}
  bool success :1;
} _VideoSfM_newTrack_presult__isset;

class VideoSfM_newTrack_presult {
 public:


  virtual ~VideoSfM_newTrack_presult() throw();
  int32_t* success;

  _VideoSfM_newTrack_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_getTracks_args__isset {
  _VideoSfM_getTracks_args__isset() : authToken(false), sessionKey(false) {}
  bool authToken :1;
  bool sessionKey :1;
} _VideoSfM_getTracks_args__isset;

class VideoSfM_getTracks_args {
 public:

  VideoSfM_getTracks_args(const VideoSfM_getTracks_args&);
  VideoSfM_getTracks_args& operator=(const VideoSfM_getTracks_args&);
  VideoSfM_getTracks_args() : authToken(), sessionKey(0) {
  }

  virtual ~VideoSfM_getTracks_args() throw();
  std::string authToken;
  int32_t sessionKey;

  _VideoSfM_getTracks_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  bool operator == (const VideoSfM_getTracks_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_getTracks_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_getTracks_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_getTracks_pargs {
 public:


  virtual ~VideoSfM_getTracks_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_getTracks_result__isset {
  _VideoSfM_getTracks_result__isset() : success(false) {}
  bool success :1;
} _VideoSfM_getTracks_result__isset;

class VideoSfM_getTracks_result {
 public:

  VideoSfM_getTracks_result(const VideoSfM_getTracks_result&);
  VideoSfM_getTracks_result& operator=(const VideoSfM_getTracks_result&);
  VideoSfM_getTracks_result() {
  }

  virtual ~VideoSfM_getTracks_result() throw();
  std::vector<Track>  success;

  _VideoSfM_getTracks_result__isset __isset;

  void __set_success(const std::vector<Track> & val);

  bool operator == (const VideoSfM_getTracks_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_getTracks_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_getTracks_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_getTracks_presult__isset {
  _VideoSfM_getTracks_presult__isset() : success(false) {}
  bool success :1;
} _VideoSfM_getTracks_presult__isset;

class VideoSfM_getTracks_presult {
 public:


  virtual ~VideoSfM_getTracks_presult() throw();
  std::vector<Track> * success;

  _VideoSfM_getTracks_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_initialize_args__isset {
  _VideoSfM_initialize_args__isset() : authToken(false), sessionKey(false) {}
  bool authToken :1;
  bool sessionKey :1;
} _VideoSfM_initialize_args__isset;

class VideoSfM_initialize_args {
 public:

  VideoSfM_initialize_args(const VideoSfM_initialize_args&);
  VideoSfM_initialize_args& operator=(const VideoSfM_initialize_args&);
  VideoSfM_initialize_args() : authToken(), sessionKey(0) {
  }

  virtual ~VideoSfM_initialize_args() throw();
  std::string authToken;
  int32_t sessionKey;

  _VideoSfM_initialize_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  bool operator == (const VideoSfM_initialize_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_initialize_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_initialize_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_initialize_pargs {
 public:


  virtual ~VideoSfM_initialize_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_initialize_result {
 public:

  VideoSfM_initialize_result(const VideoSfM_initialize_result&);
  VideoSfM_initialize_result& operator=(const VideoSfM_initialize_result&);
  VideoSfM_initialize_result() {
  }

  virtual ~VideoSfM_initialize_result() throw();

  bool operator == (const VideoSfM_initialize_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const VideoSfM_initialize_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_initialize_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_initialize_presult {
 public:


  virtual ~VideoSfM_initialize_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_fullBA_args__isset {
  _VideoSfM_fullBA_args__isset() : authToken(false), sessionKey(false), maxIter(false), reproject(true) {}
  bool authToken :1;
  bool sessionKey :1;
  bool maxIter :1;
  bool reproject :1;
} _VideoSfM_fullBA_args__isset;

class VideoSfM_fullBA_args {
 public:

  VideoSfM_fullBA_args(const VideoSfM_fullBA_args&);
  VideoSfM_fullBA_args& operator=(const VideoSfM_fullBA_args&);
  VideoSfM_fullBA_args() : authToken(), sessionKey(0), maxIter(0), reproject(false) {
  }

  virtual ~VideoSfM_fullBA_args() throw();
  std::string authToken;
  int32_t sessionKey;
  int32_t maxIter;
  bool reproject;

  _VideoSfM_fullBA_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  void __set_maxIter(const int32_t val);

  void __set_reproject(const bool val);

  bool operator == (const VideoSfM_fullBA_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    if (!(maxIter == rhs.maxIter))
      return false;
    if (!(reproject == rhs.reproject))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_fullBA_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_fullBA_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_fullBA_pargs {
 public:


  virtual ~VideoSfM_fullBA_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;
  const int32_t* maxIter;
  const bool* reproject;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_fullBA_result__isset {
  _VideoSfM_fullBA_result__isset() : success(false) {}
  bool success :1;
} _VideoSfM_fullBA_result__isset;

class VideoSfM_fullBA_result {
 public:

  VideoSfM_fullBA_result(const VideoSfM_fullBA_result&);
  VideoSfM_fullBA_result& operator=(const VideoSfM_fullBA_result&);
  VideoSfM_fullBA_result() : success(0) {
  }

  virtual ~VideoSfM_fullBA_result() throw();
  bool success;

  _VideoSfM_fullBA_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const VideoSfM_fullBA_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_fullBA_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_fullBA_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_fullBA_presult__isset {
  _VideoSfM_fullBA_presult__isset() : success(false) {}
  bool success :1;
} _VideoSfM_fullBA_presult__isset;

class VideoSfM_fullBA_presult {
 public:


  virtual ~VideoSfM_fullBA_presult() throw();
  bool* success;

  _VideoSfM_fullBA_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_windowedBA_args__isset {
  _VideoSfM_windowedBA_args__isset() : authToken(false), sessionKey(false), startFrame(false), endFrame(false), maxIter(false), reproject(true) {}
  bool authToken :1;
  bool sessionKey :1;
  bool startFrame :1;
  bool endFrame :1;
  bool maxIter :1;
  bool reproject :1;
} _VideoSfM_windowedBA_args__isset;

class VideoSfM_windowedBA_args {
 public:

  VideoSfM_windowedBA_args(const VideoSfM_windowedBA_args&);
  VideoSfM_windowedBA_args& operator=(const VideoSfM_windowedBA_args&);
  VideoSfM_windowedBA_args() : authToken(), sessionKey(0), startFrame(0), endFrame(0), maxIter(0), reproject(false) {
  }

  virtual ~VideoSfM_windowedBA_args() throw();
  std::string authToken;
  int32_t sessionKey;
  int32_t startFrame;
  int32_t endFrame;
  int32_t maxIter;
  bool reproject;

  _VideoSfM_windowedBA_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  void __set_startFrame(const int32_t val);

  void __set_endFrame(const int32_t val);

  void __set_maxIter(const int32_t val);

  void __set_reproject(const bool val);

  bool operator == (const VideoSfM_windowedBA_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    if (!(startFrame == rhs.startFrame))
      return false;
    if (!(endFrame == rhs.endFrame))
      return false;
    if (!(maxIter == rhs.maxIter))
      return false;
    if (!(reproject == rhs.reproject))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_windowedBA_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_windowedBA_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_windowedBA_pargs {
 public:


  virtual ~VideoSfM_windowedBA_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;
  const int32_t* startFrame;
  const int32_t* endFrame;
  const int32_t* maxIter;
  const bool* reproject;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_windowedBA_result__isset {
  _VideoSfM_windowedBA_result__isset() : success(false) {}
  bool success :1;
} _VideoSfM_windowedBA_result__isset;

class VideoSfM_windowedBA_result {
 public:

  VideoSfM_windowedBA_result(const VideoSfM_windowedBA_result&);
  VideoSfM_windowedBA_result& operator=(const VideoSfM_windowedBA_result&);
  VideoSfM_windowedBA_result() : success(0) {
  }

  virtual ~VideoSfM_windowedBA_result() throw();
  bool success;

  _VideoSfM_windowedBA_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const VideoSfM_windowedBA_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_windowedBA_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_windowedBA_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_windowedBA_presult__isset {
  _VideoSfM_windowedBA_presult__isset() : success(false) {}
  bool success :1;
} _VideoSfM_windowedBA_presult__isset;

class VideoSfM_windowedBA_presult {
 public:


  virtual ~VideoSfM_windowedBA_presult() throw();
  bool* success;

  _VideoSfM_windowedBA_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_finalize_args__isset {
  _VideoSfM_finalize_args__isset() : authToken(false), sessionKey(false) {}
  bool authToken :1;
  bool sessionKey :1;
} _VideoSfM_finalize_args__isset;

class VideoSfM_finalize_args {
 public:

  VideoSfM_finalize_args(const VideoSfM_finalize_args&);
  VideoSfM_finalize_args& operator=(const VideoSfM_finalize_args&);
  VideoSfM_finalize_args() : authToken(), sessionKey(0) {
  }

  virtual ~VideoSfM_finalize_args() throw();
  std::string authToken;
  int32_t sessionKey;

  _VideoSfM_finalize_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  bool operator == (const VideoSfM_finalize_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_finalize_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_finalize_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_finalize_pargs {
 public:


  virtual ~VideoSfM_finalize_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_finalize_result {
 public:

  VideoSfM_finalize_result(const VideoSfM_finalize_result&);
  VideoSfM_finalize_result& operator=(const VideoSfM_finalize_result&);
  VideoSfM_finalize_result() {
  }

  virtual ~VideoSfM_finalize_result() throw();

  bool operator == (const VideoSfM_finalize_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const VideoSfM_finalize_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_finalize_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_finalize_presult {
 public:


  virtual ~VideoSfM_finalize_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class VideoSfMClient : virtual public VideoSfMIf {
 public:
  VideoSfMClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  VideoSfMClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void authenticate(std::string& _return);
  void send_authenticate();
  void recv_authenticate(std::string& _return);
  int32_t newSession(const std::string& authToken, const std::vector<double> & camera);
  void send_newSession(const std::string& authToken, const std::vector<double> & camera);
  int32_t recv_newSession();
  int32_t cloneSession(const std::string& authToken, const int32_t oldSessionKey);
  void send_cloneSession(const std::string& authToken, const int32_t oldSessionKey);
  int32_t recv_cloneSession();
  int32_t newRsSession(const std::string& authToken, const std::vector<double> & camera, const RollingShutter::type rs, const std::vector<int32_t> & scanlines);
  void send_newRsSession(const std::string& authToken, const std::vector<double> & camera, const RollingShutter::type rs, const std::vector<int32_t> & scanlines);
  int32_t recv_newRsSession();
  int32_t newFrame(const std::string& authToken, const int32_t sessionKey, const Frame& frame);
  void send_newFrame(const std::string& authToken, const int32_t sessionKey, const Frame& frame);
  int32_t recv_newFrame();
  void getFrame(Frame& _return, const std::string& authToken, const int32_t sessionKey, const int32_t frameKey);
  void send_getFrame(const std::string& authToken, const int32_t sessionKey, const int32_t frameKey);
  void recv_getFrame(Frame& _return);
  int32_t newTrack(const std::string& authToken, const int32_t sessionKey, const Track& track);
  void send_newTrack(const std::string& authToken, const int32_t sessionKey, const Track& track);
  int32_t recv_newTrack();
  void getTracks(std::vector<Track> & _return, const std::string& authToken, const int32_t sessionKey);
  void send_getTracks(const std::string& authToken, const int32_t sessionKey);
  void recv_getTracks(std::vector<Track> & _return);
  void initialize(const std::string& authToken, const int32_t sessionKey);
  void send_initialize(const std::string& authToken, const int32_t sessionKey);
  void recv_initialize();
  bool fullBA(const std::string& authToken, const int32_t sessionKey, const int32_t maxIter, const bool reproject);
  void send_fullBA(const std::string& authToken, const int32_t sessionKey, const int32_t maxIter, const bool reproject);
  bool recv_fullBA();
  bool windowedBA(const std::string& authToken, const int32_t sessionKey, const int32_t startFrame, const int32_t endFrame, const int32_t maxIter, const bool reproject);
  void send_windowedBA(const std::string& authToken, const int32_t sessionKey, const int32_t startFrame, const int32_t endFrame, const int32_t maxIter, const bool reproject);
  bool recv_windowedBA();
  void finalize(const std::string& authToken, const int32_t sessionKey);
  void send_finalize(const std::string& authToken, const int32_t sessionKey);
  void recv_finalize();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class VideoSfMProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<VideoSfMIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (VideoSfMProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_authenticate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newSession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_cloneSession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newRsSession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newFrame(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getFrame(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTrack(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTracks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_initialize(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_fullBA(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_windowedBA(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_finalize(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  VideoSfMProcessor(boost::shared_ptr<VideoSfMIf> iface) :
    iface_(iface) {
    processMap_["authenticate"] = &VideoSfMProcessor::process_authenticate;
    processMap_["newSession"] = &VideoSfMProcessor::process_newSession;
    processMap_["cloneSession"] = &VideoSfMProcessor::process_cloneSession;
    processMap_["newRsSession"] = &VideoSfMProcessor::process_newRsSession;
    processMap_["newFrame"] = &VideoSfMProcessor::process_newFrame;
    processMap_["getFrame"] = &VideoSfMProcessor::process_getFrame;
    processMap_["newTrack"] = &VideoSfMProcessor::process_newTrack;
    processMap_["getTracks"] = &VideoSfMProcessor::process_getTracks;
    processMap_["initialize"] = &VideoSfMProcessor::process_initialize;
    processMap_["fullBA"] = &VideoSfMProcessor::process_fullBA;
    processMap_["windowedBA"] = &VideoSfMProcessor::process_windowedBA;
    processMap_["finalize"] = &VideoSfMProcessor::process_finalize;
  }

  virtual ~VideoSfMProcessor() {}
};

class VideoSfMProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  VideoSfMProcessorFactory(const ::boost::shared_ptr< VideoSfMIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< VideoSfMIfFactory > handlerFactory_;
};

class VideoSfMMultiface : virtual public VideoSfMIf {
 public:
  VideoSfMMultiface(std::vector<boost::shared_ptr<VideoSfMIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~VideoSfMMultiface() {}
 protected:
  std::vector<boost::shared_ptr<VideoSfMIf> > ifaces_;
  VideoSfMMultiface() {}
  void add(boost::shared_ptr<VideoSfMIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void authenticate(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->authenticate(_return);
    }
    ifaces_[i]->authenticate(_return);
    return;
  }

  int32_t newSession(const std::string& authToken, const std::vector<double> & camera) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newSession(authToken, camera);
    }
    return ifaces_[i]->newSession(authToken, camera);
  }

  int32_t cloneSession(const std::string& authToken, const int32_t oldSessionKey) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->cloneSession(authToken, oldSessionKey);
    }
    return ifaces_[i]->cloneSession(authToken, oldSessionKey);
  }

  int32_t newRsSession(const std::string& authToken, const std::vector<double> & camera, const RollingShutter::type rs, const std::vector<int32_t> & scanlines) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newRsSession(authToken, camera, rs, scanlines);
    }
    return ifaces_[i]->newRsSession(authToken, camera, rs, scanlines);
  }

  int32_t newFrame(const std::string& authToken, const int32_t sessionKey, const Frame& frame) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newFrame(authToken, sessionKey, frame);
    }
    return ifaces_[i]->newFrame(authToken, sessionKey, frame);
  }

  void getFrame(Frame& _return, const std::string& authToken, const int32_t sessionKey, const int32_t frameKey) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getFrame(_return, authToken, sessionKey, frameKey);
    }
    ifaces_[i]->getFrame(_return, authToken, sessionKey, frameKey);
    return;
  }

  int32_t newTrack(const std::string& authToken, const int32_t sessionKey, const Track& track) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTrack(authToken, sessionKey, track);
    }
    return ifaces_[i]->newTrack(authToken, sessionKey, track);
  }

  void getTracks(std::vector<Track> & _return, const std::string& authToken, const int32_t sessionKey) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTracks(_return, authToken, sessionKey);
    }
    ifaces_[i]->getTracks(_return, authToken, sessionKey);
    return;
  }

  void initialize(const std::string& authToken, const int32_t sessionKey) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->initialize(authToken, sessionKey);
    }
    ifaces_[i]->initialize(authToken, sessionKey);
  }

  bool fullBA(const std::string& authToken, const int32_t sessionKey, const int32_t maxIter, const bool reproject) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->fullBA(authToken, sessionKey, maxIter, reproject);
    }
    return ifaces_[i]->fullBA(authToken, sessionKey, maxIter, reproject);
  }

  bool windowedBA(const std::string& authToken, const int32_t sessionKey, const int32_t startFrame, const int32_t endFrame, const int32_t maxIter, const bool reproject) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->windowedBA(authToken, sessionKey, startFrame, endFrame, maxIter, reproject);
    }
    return ifaces_[i]->windowedBA(authToken, sessionKey, startFrame, endFrame, maxIter, reproject);
  }

  void finalize(const std::string& authToken, const int32_t sessionKey) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->finalize(authToken, sessionKey);
    }
    ifaces_[i]->finalize(authToken, sessionKey);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class VideoSfMConcurrentClient : virtual public VideoSfMIf {
 public:
  VideoSfMConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  VideoSfMConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void authenticate(std::string& _return);
  int32_t send_authenticate();
  void recv_authenticate(std::string& _return, const int32_t seqid);
  int32_t newSession(const std::string& authToken, const std::vector<double> & camera);
  int32_t send_newSession(const std::string& authToken, const std::vector<double> & camera);
  int32_t recv_newSession(const int32_t seqid);
  int32_t cloneSession(const std::string& authToken, const int32_t oldSessionKey);
  int32_t send_cloneSession(const std::string& authToken, const int32_t oldSessionKey);
  int32_t recv_cloneSession(const int32_t seqid);
  int32_t newRsSession(const std::string& authToken, const std::vector<double> & camera, const RollingShutter::type rs, const std::vector<int32_t> & scanlines);
  int32_t send_newRsSession(const std::string& authToken, const std::vector<double> & camera, const RollingShutter::type rs, const std::vector<int32_t> & scanlines);
  int32_t recv_newRsSession(const int32_t seqid);
  int32_t newFrame(const std::string& authToken, const int32_t sessionKey, const Frame& frame);
  int32_t send_newFrame(const std::string& authToken, const int32_t sessionKey, const Frame& frame);
  int32_t recv_newFrame(const int32_t seqid);
  void getFrame(Frame& _return, const std::string& authToken, const int32_t sessionKey, const int32_t frameKey);
  int32_t send_getFrame(const std::string& authToken, const int32_t sessionKey, const int32_t frameKey);
  void recv_getFrame(Frame& _return, const int32_t seqid);
  int32_t newTrack(const std::string& authToken, const int32_t sessionKey, const Track& track);
  int32_t send_newTrack(const std::string& authToken, const int32_t sessionKey, const Track& track);
  int32_t recv_newTrack(const int32_t seqid);
  void getTracks(std::vector<Track> & _return, const std::string& authToken, const int32_t sessionKey);
  int32_t send_getTracks(const std::string& authToken, const int32_t sessionKey);
  void recv_getTracks(std::vector<Track> & _return, const int32_t seqid);
  void initialize(const std::string& authToken, const int32_t sessionKey);
  int32_t send_initialize(const std::string& authToken, const int32_t sessionKey);
  void recv_initialize(const int32_t seqid);
  bool fullBA(const std::string& authToken, const int32_t sessionKey, const int32_t maxIter, const bool reproject);
  int32_t send_fullBA(const std::string& authToken, const int32_t sessionKey, const int32_t maxIter, const bool reproject);
  bool recv_fullBA(const int32_t seqid);
  bool windowedBA(const std::string& authToken, const int32_t sessionKey, const int32_t startFrame, const int32_t endFrame, const int32_t maxIter, const bool reproject);
  int32_t send_windowedBA(const std::string& authToken, const int32_t sessionKey, const int32_t startFrame, const int32_t endFrame, const int32_t maxIter, const bool reproject);
  bool recv_windowedBA(const int32_t seqid);
  void finalize(const std::string& authToken, const int32_t sessionKey);
  int32_t send_finalize(const std::string& authToken, const int32_t sessionKey);
  void recv_finalize(const int32_t seqid);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _WIN32
  #pragma warning( pop )
#endif

}}} // namespace

#endif
